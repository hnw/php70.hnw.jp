<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>num1</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/4.html#L136'>num1</a>              136 ext/bcmath/libbcmath/src/bcmath.h _PROTOTYPE(int bc_modulo, (bc_num num1, bc_num num2, bc_num *result,</span>
<span class='curline'><a href='../S/4.html#L139'>num1</a>              139 ext/bcmath/libbcmath/src/bcmath.h _PROTOTYPE(int bc_divmod, (bc_num num1, bc_num num2, bc_num *quot,</span>
<span class='curline'><a href='../S/4.html#L145'>num1</a>              145 ext/bcmath/libbcmath/src/bcmath.h _PROTOTYPE(void bc_raise, (bc_num num1, bc_num num2, bc_num *result,</span>
<span class='curline'><a href='../S/8.html#L91'>num1</a>               91 ext/bcmath/libbcmath/src/div.c   unsigned char *num1, *num2;</span>
<span class='curline'><a href='../S/8.html#L130'>num1</a>              130 ext/bcmath/libbcmath/src/div.c   num1 = (unsigned char *) safe_emalloc (1, n1-&gt;n_len+n1-&gt;n_scale, extra+2);</span>
<span class='curline'><a href='../S/8.html#L131'>num1</a>              131 ext/bcmath/libbcmath/src/div.c   if (num1 == NULL) bc_out_of_memory();</span>
<span class='curline'><a href='../S/8.html#L132'>num1</a>              132 ext/bcmath/libbcmath/src/div.c   memset (num1, 0, n1-&gt;n_len+n1-&gt;n_scale+extra+2);</span>
<span class='curline'><a href='../S/8.html#L133'>num1</a>              133 ext/bcmath/libbcmath/src/div.c   memcpy (num1+1, n1-&gt;n_value, n1-&gt;n_len+n1-&gt;n_scale);</span>
<span class='curline'><a href='../S/8.html#L177'>num1</a>              177 ext/bcmath/libbcmath/src/div.c 	  _one_mult (num1, len1+scale1+extra+1, norm, num1);</span>
<span class='curline'><a href='../S/8.html#L192'>num1</a>              192 ext/bcmath/libbcmath/src/div.c 	  if (*n2ptr == num1[qdig])</span>
<span class='curline'><a href='../S/8.html#L195'>num1</a>              195 ext/bcmath/libbcmath/src/div.c 	    qguess = (num1[qdig]*10 + num1[qdig+1]) / *n2ptr;</span>
<span class='curline'><a href='../S/8.html#L199'>num1</a>              199 ext/bcmath/libbcmath/src/div.c 	      (num1[qdig]*10 + num1[qdig+1] - *n2ptr*qguess)*10</span>
<span class='curline'><a href='../S/8.html#L200'>num1</a>              200 ext/bcmath/libbcmath/src/div.c 	       + num1[qdig+2])</span>
<span class='curline'><a href='../S/8.html#L205'>num1</a>              205 ext/bcmath/libbcmath/src/div.c 		  (num1[qdig]*10 + num1[qdig+1] - *n2ptr*qguess)*10</span>
<span class='curline'><a href='../S/8.html#L206'>num1</a>              206 ext/bcmath/libbcmath/src/div.c 		  + num1[qdig+2])</span>
<span class='curline'><a href='../S/8.html#L216'>num1</a>              216 ext/bcmath/libbcmath/src/div.c 	      ptr1 = (unsigned char *) num1+qdig+len2;</span>
<span class='curline'><a href='../S/8.html#L236'>num1</a>              236 ext/bcmath/libbcmath/src/div.c 	      ptr1 = (unsigned char *) num1+qdig+len2;</span>
<span class='curline'><a href='../S/8.html#L269'>num1</a>              269 ext/bcmath/libbcmath/src/div.c   efree (num1);</span>
<span class='curline'><a href='../S/9.html#L48'>num1</a>               48 ext/bcmath/libbcmath/src/divmod.c bc_divmod (bc_num num1, bc_num num2, bc_num *quot, bc_num *rem, int scale)</span>
<span class='curline'><a href='../S/9.html#L58'>num1</a>               58 ext/bcmath/libbcmath/src/divmod.c   rscale = MAX (num1-&gt;n_scale, num2-&gt;n_scale+scale);</span>
<span class='curline'><a href='../S/9.html#L62'>num1</a>               62 ext/bcmath/libbcmath/src/divmod.c   bc_divide (num1, num2, &amp;temp, scale);</span>
<span class='curline'><a href='../S/9.html#L66'>num1</a>               66 ext/bcmath/libbcmath/src/divmod.c   bc_sub (num1, temp, rem, rscale);</span>
<span class='curline'><a href='../S/9.html#L83'>num1</a>               83 ext/bcmath/libbcmath/src/divmod.c bc_modulo (bc_num num1, bc_num num2, bc_num *result, int scale)</span>
<span class='curline'><a href='../S/9.html#L85'>num1</a>               85 ext/bcmath/libbcmath/src/divmod.c   return bc_divmod (num1, num2, NULL, result, scale);</span>
<span class='curline'><a href='../S/20.html#L47'>num1</a>               47 ext/bcmath/libbcmath/src/raise.c bc_raise (bc_num num1, bc_num num2, bc_num *result, int scale)</span>
<span class='curline'><a href='../S/20.html#L81'>num1</a>               81 ext/bcmath/libbcmath/src/raise.c        rscale = MIN (num1-&gt;n_scale*exponent, MAX(scale, num1-&gt;n_scale));</span>
<span class='curline'><a href='../S/20.html#L85'>num1</a>               85 ext/bcmath/libbcmath/src/raise.c    power = bc_copy_num (num1);</span>
<span class='curline'><a href='../S/20.html#L86'>num1</a>               86 ext/bcmath/libbcmath/src/raise.c    pwrscale = num1-&gt;n_scale;</span>
<span class='curline'><a href='../S/338.html#L58'>num1</a>               58 ext/intl/collator/collator_sort.c 	zval num1, num2;</span>
<span class='curline'><a href='../S/338.html#L68'>num1</a>               68 ext/intl/collator/collator_sort.c 		( str1_p == ( num1_p = collator_convert_string_to_number_if_possible( str1_p, &amp;num1 ) ) ||</span>
<span class='curline'><a href='../S/338.html#L147'>num1</a>              147 ext/intl/collator/collator_sort.c 	zval num1, num2;</span>
<span class='curline'><a href='../S/338.html#L153'>num1</a>              153 ext/intl/collator/collator_sort.c 		num1_p = collator_convert_string_to_double( op1, &amp;num1 );</span>
<span class='curline'><a href='../S/1064.html#L1712'>num1</a>             1712 ext/standard/basic_functions.c 	ZEND_ARG_INFO(0, num1)</span>
<span class='curline'><a href='../S/1121.html#L550'>num1</a>              550 ext/standard/math.c 	double num1, num2;</span>
<span class='curline'><a href='../S/1121.html#L553'>num1</a>              553 ext/standard/math.c 	if (zend_parse_parameters(ZEND_NUM_ARGS(), "dd", &amp;num1, &amp;num2) == FAILURE) {</span>
<span class='curline'><a href='../S/1121.html#L558'>num1</a>              558 ext/standard/math.c 		Z_PARAM_DOUBLE(num1)</span>
<span class='curline'><a href='../S/1121.html#L562'>num1</a>              562 ext/standard/math.c 	RETURN_DOUBLE(atan2(num1, num2));</span>
<span class='curline'><a href='../S/1121.html#L916'>num1</a>              916 ext/standard/math.c 	double num1, num2;</span>
<span class='curline'><a href='../S/1121.html#L919'>num1</a>              919 ext/standard/math.c 	if (zend_parse_parameters(ZEND_NUM_ARGS(), "dd", &amp;num1, &amp;num2) == FAILURE) {</span>
<span class='curline'><a href='../S/1121.html#L924'>num1</a>              924 ext/standard/math.c 		Z_PARAM_DOUBLE(num1)</span>
<span class='curline'><a href='../S/1121.html#L930'>num1</a>              930 ext/standard/math.c 	RETURN_DOUBLE(hypot(num1, num2));</span>
<span class='curline'><a href='../S/1121.html#L932'>num1</a>              932 ext/standard/math.c 	RETURN_DOUBLE(_hypot(num1, num2));</span>
<span class='curline'><a href='../S/1121.html#L934'>num1</a>              934 ext/standard/math.c 	RETURN_DOUBLE(sqrt((num1 * num1) + (num2 * num2)));</span>
<span class='curline'><a href='../S/1121.html#L1456'>num1</a>             1456 ext/standard/math.c 	double num1, num2;</span>
<span class='curline'><a href='../S/1121.html#L1459'>num1</a>             1459 ext/standard/math.c 	if (zend_parse_parameters(ZEND_NUM_ARGS(), "dd",  &amp;num1, &amp;num2) == FAILURE) {</span>
<span class='curline'><a href='../S/1121.html#L1464'>num1</a>             1464 ext/standard/math.c 		Z_PARAM_DOUBLE(num1)</span>
<span class='curline'><a href='../S/1121.html#L1469'>num1</a>             1469 ext/standard/math.c 	RETURN_DOUBLE(fmod(num1, num2));</span>
</pre>
</body>
</html>
