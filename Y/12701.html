<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>bitmap</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/229.html#L109'>bitmap</a>            109 ext/gd/libgd/gd_wbmp.c 				wbmp-&gt;bitmap[pos] = WBMP_BLACK;</span>
<span class='curline'><a href='../S/229.html#L153'>bitmap</a>            153 ext/gd/libgd/gd_wbmp.c 			if (wbmp-&gt;bitmap[pos++] == WBMP_WHITE) {</span>
<span class='curline'><a href='../S/244.html#L625'>bitmap</a>            625 ext/gd/libgd/gdft.c static char * gdft_draw_bitmap (gdCache_head_t *tc_cache, gdImage * im, int fg, FT_Bitmap bitmap, int pen_x, int pen_y)</span>
<span class='curline'><a href='../S/244.html#L639'>bitmap</a>            639 ext/gd/libgd/gdft.c 		for (row = 0; row &lt; bitmap.rows; row++) {</span>
<span class='curline'><a href='../S/244.html#L640'>bitmap</a>            640 ext/gd/libgd/gdft.c 			pc = row * bitmap.pitch;</span>
<span class='curline'><a href='../S/244.html#L648'>bitmap</a>            648 ext/gd/libgd/gdft.c 			for (col = 0; col &lt; bitmap.width; col++, pc++) {</span>
<span class='curline'><a href='../S/244.html#L650'>bitmap</a>            650 ext/gd/libgd/gdft.c 				if (bitmap.pixel_mode == ft_pixel_mode_grays) {</span>
<span class='curline'><a href='../S/244.html#L654'>bitmap</a>            654 ext/gd/libgd/gdft.c 					level = (bitmap.buffer[pc] * gdAlphaMax / (bitmap.num_grays - 1));</span>
<span class='curline'><a href='../S/244.html#L655'>bitmap</a>            655 ext/gd/libgd/gdft.c 				} else if (bitmap.pixel_mode == ft_pixel_mode_mono) {</span>
<span class='curline'><a href='../S/244.html#L657'>bitmap</a>            657 ext/gd/libgd/gdft.c 					level = ((bitmap.buffer[(col&gt;&gt;3)+pcr]) &amp; (1&lt;&lt;(~col&amp;0x07))) ? gdAlphaTransparent : gdAlphaOpaque;</span>
<span class='curline'><a href='../S/244.html#L694'>bitmap</a>            694 ext/gd/libgd/gdft.c 	for (row = 0; row &lt; bitmap.rows; row++) {</span>
<span class='curline'><a href='../S/244.html#L696'>bitmap</a>            696 ext/gd/libgd/gdft.c 		pc = row * bitmap.pitch;</span>
<span class='curline'><a href='../S/244.html#L698'>bitmap</a>            698 ext/gd/libgd/gdft.c 		if (bitmap.pixel_mode==ft_pixel_mode_mono) {</span>
<span class='curline'><a href='../S/244.html#L708'>bitmap</a>            708 ext/gd/libgd/gdft.c 		for (col = 0; col &lt; bitmap.width; col++, pc++) {</span>
<span class='curline'><a href='../S/244.html#L709'>bitmap</a>            709 ext/gd/libgd/gdft.c 			if (bitmap.pixel_mode == ft_pixel_mode_grays) {</span>
<span class='curline'><a href='../S/244.html#L715'>bitmap</a>            715 ext/gd/libgd/gdft.c 				tc_key.pixel = ((bitmap.buffer[pc] * NUMCOLORS) + bitmap.num_grays / 2) / (bitmap.num_grays - 1);</span>
<span class='curline'><a href='../S/244.html#L716'>bitmap</a>            716 ext/gd/libgd/gdft.c 			} else if (bitmap.pixel_mode == ft_pixel_mode_mono) {</span>
<span class='curline'><a href='../S/244.html#L717'>bitmap</a>            717 ext/gd/libgd/gdft.c 				tc_key.pixel = ((bitmap.buffer[pc / 8] &lt;&lt; (pc % 8)) &amp; 128) ? NUMCOLORS : 0;</span>
<span class='curline'><a href='../S/244.html#L719'>bitmap</a>            719 ext/gd/libgd/gdft.c 				tc_key.pixel = ((bitmap.buffer[(col&gt;&gt;3)+pcr]) &amp; (1&lt;&lt;(~col&amp;0x07))) ? NUMCOLORS : 0;</span>
<span class='curline'><a href='../S/244.html#L1150'>bitmap</a>           1150 ext/gd/libgd/gdft.c 			gdft_draw_bitmap(tc_cache, im, fg, bm-&gt;bitmap, x + x1 + ((pen.x + 31) &gt;&gt; 6) + bm-&gt;left, y + y1 + ((pen.y + 31) &gt;&gt; 6) - bm-&gt;top);</span>
<span class='curline'><a href='../S/259.html#L128'>bitmap</a>            128 ext/gd/libgd/wbmp.c   if ((wbmp-&gt;bitmap = (int *) safe_emalloc(sizeof(int), width * height, 0)) == NULL)</span>
<span class='curline'><a href='../S/259.html#L137'>bitmap</a>            137 ext/gd/libgd/wbmp.c   for (i = 0; i &lt; width * height; wbmp-&gt;bitmap[i++] = color);</span>
<span class='curline'><a href='../S/259.html#L195'>bitmap</a>            195 ext/gd/libgd/wbmp.c   if ((wbmp-&gt;bitmap = (int *) safe_emalloc((size_t)wbmp-&gt;width * wbmp-&gt;height, sizeof(int), 0)) == NULL)</span>
<span class='curline'><a href='../S/259.html#L218'>bitmap</a>            218 ext/gd/libgd/wbmp.c 		      wbmp-&gt;bitmap[pos] = WBMP_WHITE;</span>
<span class='curline'><a href='../S/259.html#L222'>bitmap</a>            222 ext/gd/libgd/wbmp.c 		      wbmp-&gt;bitmap[pos] = WBMP_BLACK;</span>
<span class='curline'><a href='../S/259.html#L271'>bitmap</a>            271 ext/gd/libgd/wbmp.c 	  octet |= ((wbmp-&gt;bitmap[row * wbmp-&gt;width + col] == 1) ? WBMP_WHITE : WBMP_BLACK) &lt;&lt; --bitpos;</span>
<span class='curline'><a href='../S/259.html#L296'>bitmap</a>            296 ext/gd/libgd/wbmp.c   gdFree (wbmp-&gt;bitmap);</span>
<span class='curline'><a href='../S/259.html#L314'>bitmap</a>            314 ext/gd/libgd/wbmp.c 	  if (wbmp-&gt;bitmap[wbmp-&gt;width * row + col] == WBMP_BLACK)</span>
<span class='curline'><a href='../S/260.html#L32'>bitmap</a>             32 ext/gd/libgd/wbmp.h     int *bitmap;        /* pointer to data: 0 = WHITE , 1 = BLACK */</span>
<span class='curline'><a href='../S/1334.html#L50'>bitmap</a>             50 ext/zip/lib/zip_source_supports.c     zip_int64_t bitmap;</span>
<span class='curline'><a href='../S/1334.html#L53'>bitmap</a>             53 ext/zip/lib/zip_source_supports.c     bitmap = ZIP_SOURCE_MAKE_COMMAND_BITMASK(cmd0);</span>
<span class='curline'><a href='../S/1334.html#L63'>bitmap</a>             63 ext/zip/lib/zip_source_supports.c         bitmap |= ZIP_SOURCE_MAKE_COMMAND_BITMASK(cmd);</span>
<span class='curline'><a href='../S/1334.html#L67'>bitmap</a>             67 ext/zip/lib/zip_source_supports.c     return bitmap;</span>
</pre>
</body>
</html>
